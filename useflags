#!/usr/bin/perl
use strict;
use integer;
use Pod::Usage;
use Getopt::Long;

=head1 NAME

useflags - save or compare useflags

=head1 SYNOPSIS

B<useflags> [options] B<save>|B<diff>|B<print>|B<cat>|B<diff64>|B<help>|B<man>

B<useflags> [options] B<save> I<file>

B<useflags> [options] B<diff> I<file>

B<useflags> [options] B<diff> I<file1> I<file2>

B<useflags> [options] B<cat> I<file>

B<useflags --man> or <useflags man> for a detailed description

=head1 DESCRIPTION

Note that I<savepath> defaults to F</etc/portage/useflags>.
This path can be changed with the option F<-f>

=over 8

=item B<useflags> [options] B<save>

save useflags to I<savepath>

=item B<useflags> [options] B<save> I<file>

save useflags to I<file>

=item B<useflags> [options] B<diff>

diff useflags saved in I<savepath> with current useflags

=item B<useflags> [options] B<diff> I<file>

diff useflags saved in I<file> with those saved in I<savepath>

=item B<useflags> [options] B<diff> I<file1> I<file2>

diff current useflags saved in I<file1> with those saved in F<file2>

=item B<useflags> [options] B<print>

print current useflags

=item B<useflags> [options] B<cat>

print useflags saved in I<savepath>

=item B<useflags> [options] B<cat> I<file>

print useflags saved in I<file>

=item B<useflags> [options] B<diff64>

same as:
B<useflags> [options] B<diff> B</gentoo32>I<savepath> B</gentoo64>I<savepath>

=back

=head1 PROBLEMS

This script does not set the defaults according to use.defaults -
this corresponds to the behaviour of F<E<gt>=portage-2.1*> but not to
F<E<lt>=portage-2.0*>.

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--help> or B<-h>

Display brief help

=item B<--man> or B<-?>

Display extended help as a manpage

=item B<--brief> or B<-b>

Do not consider full information, only print/store/compare
whether the useflags are effectively "on", "off" or "minus"

=item B<--verbose> or B<-v>

This is the default (and the opposite of B<--brief>)

=item B<--file=>I<pathname> or B<-f> I<pathname>

Use I<pathname> as I<savepath>

=item B<--reverse> or B<-r>

Reverse the output when comparing two sets of useflags,
i.e. swap the meaning of old/new.

=item B<-->

Last option

=back

=head1 VERSION

Version 3.4

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

sub message { my($text) = @_;
	print STDERR "useflags: $text\n";
}
sub fatal { my($text) = @_;
	&message($text);
	exit 2
}

# Parse Options:

my $brief = '';
my $verbose = '';
my $savepath = '/etc/portage/useflags';
my $reverse = '';

$Getopt::Long::bundling = 1;
GetOptions(
	'brief!', \$brief,
	'b', \$brief,
	'verbose!', \$verbose,
	'v', \$verbose,
	'reverse!', \$reverse,
	'r', \$reverse,
	'file|path|savepath|save|f|s|p=s', \$savepath,
	'help|h', sub { pod2usage(0) },
	'man|?', sub { pod2usage(-verbose => 2) }
) or pod2usage(1);
pod2usage(2) unless(@ARGV);
my $action = $ARGV[0];

# Interpret the options:

$verbose and $brief = '';


# Some constants: These are the index numbers of the array stored in %useflags

my $set = 0;
my $manual = 1;
my $default = 2;
my $masked = 3;
my $documented = 4;


# Transform such an array to readable text or vice versa:

sub entry2text { my($arrref) = @_;
	my $isset = ($arrref->[$set]);
	if($brief) {
		if($arrref->[$masked]) {
			return "minus"
		}
		if($isset) {
			if($isset > 0) {
				return "on"
			} else {
				return "minus"
			}
		}
		return "off"
	}
	my $rvalue;
	if($isset) {
		if($isset > 0) {
			$rvalue = "on"
		} else {
			$rvalue = "minus"
		}
	} else {
		$rvalue = "off"
	}
	if($arrref->[$manual]) {
		$rvalue .= ", make.conf"
	}
	if($arrref->[$default]) {
		$rvalue .= ", default"
	}
	unless($arrref->[$documented]) {
		$rvalue .= ", undocumented"
	}
	if($arrref->[$masked]) {
		$rvalue = "($rvalue)"
	}
	return $rvalue
}

sub text2entry { my($arrref,$text) = @_;
	$arrref->[$set] = ($text =~ /\bon\b/i);
	$arrref->[$manual] = ($text =~ /\bma[kn]/i);
	if(($text =~ /\bmin/i) || ($text =~ /\-/) || ($text =~ /\bneg/i) ||
		(($text =~ /\bfor/i) && ($text =~ /\boff/i))) {
		$arrref->[$set] = -1;
		$arrref->[$manual] = -1
	}
	$arrref->[$default] = ($text =~ /\bdef/i);
	$arrref->[$documented] = !($text =~ /\bundoc/i);
	$arrref->[$masked] = (($text =~ /\bmask/i) || ($text =~ /\(/) )
}

# return reference to the entry $name in the hash %$useflags.
# If $name does not exist, the entry becomes an empty array

sub entry { my($useflags, $name) = @_;
	exists(${$useflags}{$name}) or ${$useflags}{$name} = ['','','','',''];
	return ${$useflags}{$name}
}

# Consider entry $name in the hash %$useflags - this is an array.
# If the array entry $nr is empty (or if $force is true), store $value.
# If in addition $secnr is nonempty (and $value is stored), store the value
# also into array entry $secnr.

sub store { my($force, $useflags, $name, $nr, $secnr, $value) = @_;
	my $entry = &entry($useflags, $name);
	if($force || ($entry->[$nr] eq '')) {
		$entry->[$nr] = $value;
		if($secnr ne '') {
			$entry->[$secnr] = $value
		}
	}
}

# Set/unset "manual" all values in the hash %$useflags which match $match.

sub useset { my($useflags, $match, $doset) = @_;
	unless($match =~ /[\?\*]/) {
		&store(1, $useflags, $match, $manual, $set, $doset);
		return
	}
	$match =~ s/\?/./g;
	$match =~ s/\*/.*/g;
	for(keys(%$useflags)) {
		if(/^$match$/) {
			&store(1, $useflags, $_, $manual, $set, $doset)
		}
	}
}

# Function to parse a profile recursively

sub readprofile { my($mustexist, $profile, $useflags, $count) = @_;
	if($mustexist && !(-d $profile)) {
		&fatal("$profile is not a directory")
	}
	if($count > 1000) {
		&fatal("profile has too many parents; probably recursion")
	}
	if(-r "$profile/parent") {
		my @parents = ();
		open(IN, '<', "$profile/parent") or
			&fatal("cannot read $profile/parent");
		while(<IN>) {
			chomp();
			s/^\s*([^\s]*).*$/$1/;
			s/^#.*//;
			if($_ ne '') {
				push(@parents, $_)
			}
		}
		close(IN);
		for(@parents) {
			my $name = $_;
			$name = "$profile/$_" unless(/^\//);
			&readprofile(1, $name, $useflags, $count + 1)
		}
	}
	&readprofiledata($profile, $useflags, 1)
}

sub readprofiledata { my($profile, $useflags, $readmakedefaults) = @_;
	if(-e "$profile/use.mask") {
		open(IN, '<', "$profile/use.mask") or
			&fatal("cannot read $profile/use.mask");
		while(<IN>) {
			chomp();
			s/^\s*([^\s]*).*/$1/;
			s/^#.*//;
			if($_ ne '') {
				if(/^\-(.*)/) {
					&store(1, $useflags, $1, $masked, '', 0)
				} else {
					&store('', $useflags, $_, $masked, '', 1)
				}
			}
		}
		close(IN)
	}
	if(-e "$profile/use.desc") {
		open(IN, '<', "$profile/use.desc") or
			&fatal("cannot read $profile/use.desc");
		while(<IN>) {
			chomp();
			s/^\s*([^\s]*).*/$1/;
			s/^#.*//;
			if($_ ne '') {
				&store(1, $useflags, $_, $documented, '', 1)
			}
		}
		close(IN)
	}
	if(-e "$profile/use.local.desc") {
		open(IN, '<', "$profile/use.local.desc") or
			&fatal("cannot read $profile/use.local.desc");
		while(<IN>) {
			chomp();
			s/^\s*([^\s]*).*/$1/;
			s/^#.*//;
			s/^[^:]*://;
			if($_ ne '')
				{ &store(1, $useflags, $_, $documented, '', 1) }
		}
		close(IN)
	}
	# We read the use.defaults to find undocumented useflags,
	# but we do not set them.
	if(-e "$profile/use.defaults") {
		open(IN, '<', "$profile/use.defaults") or
			&fatal("cannot read $profile/use.defaults");
		while(<IN>) {
			chomp();
			s/^\s*([^\s]*).*$/$1/;
			s/^#.*//;
			if($_ ne '') {
				&entry($useflags, $_)
			}
		}
		close(IN)
	}
	return unless($readmakedefaults);
	if(-e "$profile/make.defaults") {
		(-r "$profile/make.defaults") or
			&fatal("cannot read $profile/make.defaults");
		my $iuse = `bash -c \'\. \"$profile/make.defaults\" ; printf \%s \"\$USE\"\'`;
		&useset_profile($iuse, $useflags)
	}
}

sub useset_profile {
	my $useflags;
	($_, $useflags) = @_;
	for(split()) {
		chomp();
		s/^\s*([^\s]*).*$/$1/;
		if($_ ne '') {
			if(/^\-(.*)/) {
				&store('', $useflags, $1, $default, $set, 0)
			} else {
				&store('', $useflags, $_, $default, $set, 1)
			}
		}
	}
}

my $eix_functions = undef;
sub eixreadvar { my($name) = @_;
	return `\. \'$eix_functions\' \&\& ReadVar x $name \&\& printf \'\%s\' \"\$x\"`
}

sub eixreadprofile { my ($useflags) = @_;
	my $profile_paths = `eix --print-profile-paths 2>/dev/null`;
	chomp($profile_paths);
	return '' if($profile_paths eq '');
	for my $profile (split('\0', $profile_paths)) {
		chomp($profile);
		chop($profile);
		&readprofiledata($profile, $useflags, '') unless($profile eq '')
	}
	return 1
}

sub getflags { my($useflags) = @_;
	# "Parse" the values of USE, PORTDIR, PORTDIR_OVERLAY from make.conf
	# and store it in into $iuse, $portdir, $overlays
	if(!defined($eix_functions)) {
		$eix_functions = `command -v eix-functions.sh 2\>/dev/null`;
		chomp($eix_functions)
	}
	my($iuse, @repos, $configroot);
	if($eix_functions ne '') {
		$ENV{'PRINT_APPEND'} = '';
		my $portdir = &eixreadvar('PORTDIR');
		chop($portdir);
		$portdir = '/usr/portage' if($portdir eq '');
		$_ = $portdir . ' ' . &eixreadvar('PORTDIR_OVERLAY');
		@repos = split();
		$configroot = &eixreadvar('PORTAGE_CONFIGROOT');
		if(&eixreadprofile($useflags)) {
			for(@repos) {
				&readprofiledata("$_/profiles", $useflags, '')
			}
			&readprofiledata("${configroot}/etc/portage/profile", $useflags, '');
			$iuse = `eix --print USE.profile`;
			&useset_profile($iuse, $useflags);
			&useset_make_conf(&eixreadvar('USE'), $useflags);
			return
		}
	} else {
		$_ = `x=\`portageq envvar EROOT 2>/dev/null\`
portageq get_repo_path \"\$x\" \`portageq get_repos \"\$x\" 2>/dev/null\` 2>/dev/null`;
		@repos = split();
		$configroot = $ENV{'PORTAGE_CONFIGROOT'};
		$configroot = '' unless(defined($configroot));
	}
	my $iuse;
	if(-r "${configroot}/etc/make.conf") {
		$iuse = `bash -c \'\. ${configroot}/etc/make.conf ; printf \%s \"\$USE\"\'`
	} else {
		$iuse = ''
	}
	if(-r "${configroot}/etc/portage/make.conf") {
		$iuse .= ' ' if($iuse ne '');
		$iuse .= `bash -c \'\. ${configroot}/etc/portage/make.conf ; printf \%s \"\$USE\"\'`
	}

	# Now we parse all the profiles
	# (in /etc/make.profile, @repos, and in /etc/portage/profile)
	# using the recursive function &readprofile.

	%{$useflags} = ();
	if(-d "${configroot}/etc/make.profile") {
		&readprofile(1, "${configroot}/etc/make.profile", $useflags)
	} elsif(-d "${configroot}/etc/portage/make.profile") {
		&readprofile(1, "${configroot}/etc/portage/make.profile", $useflags)
	} else {
		&fatal("cannot find directory ${configroot}/etc\{,/portage\}/make.profile")
	}
	for(@repos) {
		&readprofile('', "$_/profiles", $useflags)
	}
	&readprofile('', "${configroot}/etc/portage/profile", $useflags);
	&useset_make_conf($iuse, $useflags);
}

# Now we interpret the value of the USE variable in /etc/make.conf:
sub useset_make_conf {
	my $useflags;
	($_, $useflags) = @_;
	(/^\s*$/) and
		&fatal("No USE variable specified in /etc/make.conf or /etc/portage/make.conf");
	for(split()) {
		chomp();
		s/^\s*([^\s]*).*$/$1/;
		if(/^\-(.*)/) {
			&useset($useflags, $1, -1)
		} else {
			&useset($useflags, $_, 1)
		}
	}
}

sub printflags { my($useflags) = @_;
	for(sort(keys(%$useflags))) {
		my $entry = &entry($useflags, $_);
		print "$_: ",&entry2text($entry),"\n" or &fatal("write error")
	}
}

sub saveflags { my($useflags, $name) = @_;
	open(OUT, '>', $name) or &fatal("cannot write to $name");
	select(OUT);
	&printflags($useflags);
	close(OUT);
	select(STDOUT);
}

sub loadflags { my($useflags, $name) = @_;
	%{$useflags} = ();
	open(IN, '<', $name) or &fatal("cannot read $name");
	while(<IN>) {
		chomp();
		s/^\s*//;
		s/\s*$//;
		s/^#.*//;
		if($_ ne '') {
			/^([^\s:]*)\s*[^:]*\s*(.*)/;
			if($1 ne '') {
				my $string = $2; # make sure to avoid side effects
				my $entry = &entry($useflags, $1);
				&text2entry($entry, $string);
			}
		}
	}
}

sub compareflags { my($oldflags, $newflags);
	if($reverse) {
		($newflags, $oldflags) = @_
	} else {
		($oldflags, $newflags) = @_
	}
	my @array = (keys %$oldflags);
	push(@array, (keys %$newflags));
	my $previous = '#';
	for(sort(@array)) {
		if($_ ne $previous) {
			$previous = $_; # make sure to avoid side effects
			my $old = 'NONE';
			my $new = $old;
			if(exists(${$oldflags}{$previous})) {
				$old = &entry2text(&entry($oldflags, $previous))
			}
			if(exists(${$newflags}{$previous})) {
				$new = &entry2text(&entry($newflags, $previous))
			}
			if($old ne $new) {
				print "$previous: $old -> $new\n"
			}
		}
	}
}

my %useflags = (); keys %useflags = 2000;
my %altflags = (); keys %altflags = 2000;

if($action =~ /save$/i || $action =~ /store/i) {
	my $name = $savepath;
	if(scalar(@ARGV) == 2) {
		$name = $ARGV[1]
	} elsif(scalar(@ARGV) != 1) {
		pod2usage('too many arguments for "save"')
	}
	&getflags(\%useflags);
	&saveflags(\%useflags, $name)
} elsif($action =~ /echo/i || $action =~ /print/i) {
	&getflags(\%useflags);
	&printflags(\%useflags)
} elsif($action =~ /cat/i || $action =~ /old/i || $action =~ /saved/i) {
	my $name = $savepath;
	if(scalar(@ARGV) == 2) {
		$name = $ARGV[1]
	} elsif(scalar(@ARGV) != 1) {
		pod2usage('too many arguments for "cat"')
	}
	&loadflags(\%useflags, $name);
	&printflags(\%useflags)
} elsif($action =~ /diff\D*(\d+)/i || $action =~ /comp\D*(\d+)/i) {
	&loadflags(\%useflags, "/gentoo32$savepath");
	&loadflags(\%altflags, "/gentoo64$savepath");
	&compareflags(\%useflags, \%altflags)
} elsif($action =~ /diff/i || $action =~ /comp/i) {
	if(scalar(@ARGV) == 3) {
		&loadflags(\%useflags, $ARGV[1]);
		&loadflags(\%altflags, $ARGV[2]);
	} elsif(scalar(@ARGV) == 2) {
		&loadflags(\%useflags, $ARGV[1]);
		&loadflags(\%altflags, $savepath);
	} elsif(scalar(@ARGV) == 1) {
		&loadflags(\%useflags, $savepath);
		&getflags(\%altflags);
	} else {
		pod2usage('too many arguments for "diff"')
	}
	&compareflags(\%useflags, \%altflags)
} elsif($action =~ /help/i) {
	pod2usage(0)
} elsif($action =~ /man/i) {
	pod2usage(-verbose => 2)
} else {
	pod2usage("Unknown action: $action")
}
