#! /usr/bin/perl
use strict;
use integer;
use Pod::Usage;
use Getopt::Long;

=head1 NAME

useflags - save or compare useflags

=head1 SYNOPSIS

B<useflags> [options] B<save>|B<diff>|B<print>|B<cat>|B<diff64>|B<help>|B<man>

B<useflags> [options] B<save> I<file>

B<useflags> [options] B<diff> I<file>

B<useflags> [options] B<diff> I<file1> I<file2>

B<useflags> [options] B<cat> I<file>

B<useflags --man> or <useflags man> for a detailed description

=head1 DESCRIPTION

Note that I<savepath> defaults to F</etc/portage/useflags>.
This path can be changed with the option F<-f>

=over 8

=item B<useflags> [options] B<save>

save useflags to I<savepath>

=item B<useflags> [options] B<save> I<file>

save useflags to I<file>

=item B<useflags> [options] B<diff>

diff useflags saved in I<savepath> with current useflags

=item B<useflags> [options] B<diff> I<file>

diff useflags saved in I<file> with those saved in I<savepath>

=item B<useflags> [options] B<diff> I<file1> I<file2>

diff current useflags saved in I<file1> with those saved in F<file2>

=item B<useflags> [options] B<print>

print current useflags

=item B<useflags> [options] B<cat>

print useflags saved in I<savepath>

=item B<useflags> [options] B<cat> I<file>

print useflags saved in I<file>

=item B<useflags> [options] B<diff64>

same as:
B<useflags> [options] B<diff> B</gentoo32>I<savepath> B</gentoo64>I<savepath>

=back

=head1 PROBLEMS

This script does not set the defaults according to use.defaults -
this corresponds to the behaviour of F<E<gt>=portage-2.1*> but not to
F<E<lt>=portage-2.0*>.

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--help> or B<-h>

Display brief help

=item B<--man> or B<-?>

Display extended help as a manpage

=item B<--brief> or B<-b>

Do not consider full information, only print/store/compare
whether the useflags are effectively "on", "off" or "minus"

=item B<--verbose> or B<-v>

This is the default (and the opposite of B<--brief>)

=item B<--file=>I<pathname> or B<-f> I<pathname>

Use I<pathname> as I<savepath>

=item B<--reverse> or B<-r>

Reverse the output when comparing two sets of useflags,
i.e. swap the meaning of old/new.

=item B<-->

Last option

=back

=head1 VERSION

Version 2.6

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

sub message { my($text) = @_;
	print STDERR "useflags: $text\n";
}
sub fatal { my($text) = @_;
	&message($text);
	exit 2
}

# Parse Options:

my $brief = '';
my $verbose = '';
my $savepath = '/etc/portage/useflags';
my $reverse = '';

$Getopt::Long::bundling = 1;
GetOptions(
	'brief!', \$brief,
	'b', \$brief,
	'verbose!', \$verbose,
	'v', \$verbose,
	'reverse!', \$reverse,
	'r', \$reverse,
	'file|path|savepath|save|f|s|p=s', \$savepath,
	'help|h', sub { pod2usage(0) },
	'man|?', sub { pod2usage(-verbose => 2) }
) or pod2usage(1);
$#ARGV<0 and pod2usage(2);
my $action = $ARGV[0];

# Interpret the options:

$verbose and $brief = '';


# Some constants: These are the index numbers of the array stored in %useflags

my $set = 0;
my $manual = 1;
my $default = 2;
my $masked = 3;
my $documented = 4;


# Transform such an array to readable text or vice versa:

sub entry2text { my($arrref) = @_;
	my $isset = ($arrref->[$set]);
	if($brief) {
		if($arrref->[$masked]) {
			return "minus"
		}
		if($isset) {
			if($isset > 0) {
				return "on"
			} else {
				return "minus"
			}
		}
		return "off"
	}
	my $rvalue;
	if($isset) {
		if($isset > 0) {
			$rvalue = "on"
		} else {
			$rvalue = "minus"
		}
	} else {
		$rvalue = "off"
	}
	if($arrref->[$manual]) {
		$rvalue .= ", make.conf"
	}
	if($arrref->[$default]) {
		$rvalue .= ", default"
	}
	unless($arrref->[$documented]) {
		$rvalue .= ", undocumented"
	}
	if($arrref->[$masked]) {
		$rvalue = "($rvalue)"
	}
	return $rvalue
}

sub text2entry { my($arrref,$text) = @_;
	$arrref->[$set] = ($text =~ /\bon\b/i);
	$arrref->[$manual] = ($text =~ /\bma[kn]/i);
	if(($text =~ /\bmin/i) || ($text =~ /\-/) || ($text =~ /\bneg/i) ||
		(($text =~ /\bfor/i) && ($text =~ /\boff/i))) {
		$arrref->[$set] = -1;
		$arrref->[$manual] = -1
	}
	$arrref->[$default] = ($text =~ /\bdef/i);
	$arrref->[$documented] = !($text =~ /\bundoc/i);
	$arrref->[$masked] = (($text =~ /\bmask/i) || ($text =~ /\(/) )
}

# return reference to the entry $name in the hash %$useflags.
# If $name does not exist, the entry becomes an empty array

sub entry { my($useflags,$name) = @_;
	exists(${$useflags}{$name}) or ${$useflags}{$name} = ['','','','',''];
	return ${$useflags}{$name}
}

# Consider entry $name in the hash %$useflags - this is an array.
# If the array entry $nr is empty (or if $force is true), store $value.
# If in addition $secnr is nonempty (and $value is stored), store the value
# also into array entry $secnr.

sub store { my($force, $useflags, $name, $nr, $secnr, $value) = @_;
	my $entry = &entry($useflags, $name);
	if($force || ($entry->[$nr] eq '')) {
		$entry->[$nr] = $value;
		if($secnr ne '') {
			$entry->[$secnr] = $value
		}
	}
}

# Set/unset "manual" all values in the hash %$useflags which match $match.

sub useset { my($useflags, $match, $doset) = @_;
	unless($match =~ /[\?\*]/) {
		&store(1, $useflags, $match, $manual, $set, $doset);
		return
	}
	$match =~ s/\?/./g;
	$match =~ s/\*/.*/g;
	foreach (keys %$useflags) {
		if(/^$match$/) {
			&store(1, $useflags, $_, $manual, $set, $doset)
		}
	}
}

# Function to parse a profile recursively

sub readprofile { my($mustexist, $profile, $useflags, $count) = @_;
	if($mustexist && !(-d $profile)) {
		&fatal("$profile is not a directory")
	}
	if($count > 1000) {
		&fatal("profile has too many parents; probably recursion")
	}
	if(-r "$profile/parent") {
		my @parents = ();
		open(IN, '<', "$profile/parent") or
			&fatal("cannot read $profile/parent");
		while(<IN>) {
			chomp;
			s/^\s*([^\s]*).*$/$1/;
			s/^#.*//;
			if($_ ne '') {
				push(@parents, $_)
			}
		}
		close(IN);
		for(@parents) {
			my $name = $_;
			$name = "$profile/$_" unless(/^\//);
			&readprofile(1, $name, $useflags, $count+1)
		}
	}
	if(-e "$profile/use.mask") {
		open(IN, '<', "$profile/use.mask") or
			&fatal("cannot read $profile/use.mask");
		while(<IN>) {
			chomp;
			s/^\s*([^\s]*).*/$1/;
			s/^#.*//;
			if($_ ne '') {
				if(/^\-(.*)/) {
					&store(1, $useflags, $1, $masked, '', 0)
				} else {
					&store('', $useflags, $_, $masked, '', 1)
				}
			}
		}
		close(IN)
	}
	if(-e "$profile/use.desc") {
		open(IN, '<', "$profile/use.desc") or
			&fatal("cannot read $profile/use.desc");
		while(<IN>) {
			chomp;
			s/^\s*([^\s]*).*/$1/;
			s/^#.*//;
			if($_ ne '') {
				&store(1, $useflags, $_, $documented, '', 1)
			}
		}
		close(IN)
	}
	if(-e "$profile/use.local.desc") {
		open(IN, '<', "$profile/use.local.desc") or
			&fatal("cannot read $profile/use.local.desc");
		while(<IN>) {
			chomp;
			s/^\s*([^\s]*).*/$1/;
			s/^#.*//;
			s/^[^:]*://;
			if($_ ne '')
				{ &store(1, $useflags, $_, $documented, '', 1) }
		}
		close(IN)
	}
	# We read the use.defaults to find undocumented useflags, 
	# but we do not set them.
	if(-e "$profile/use.defaults") {
		open(IN, '<', "$profile/use.defaults") or
			&fatal("cannot read $profile/use.defaults");
		while(<IN>) {
			chomp;
			s/^\s*([^\s]*).*$/$1/;
			s/^#.*//;
			if($_ ne '') {
				&entry($useflags, $_)
			}
		}
		close(IN)
	}
	if(-e "$profile/make.defaults") {
		(-r "$profile/make.defaults") or
			&fatal("cannot read $profile/make.defaults");
		$_ = `bash -c \'\. \"$profile/make.defaults\" ; printf \%s \"\$USE\"\'`;
		foreach (split) {
			chomp;
			s/^\s*([^\s]*).*$/$1/;
			if($_ ne '') {
				if(/^\-(.*)/) {
					&store('', $useflags, $1, $default, $set, 0)
				} else {
					&store('', $useflags, $_, $default, $set, 1)
				}
			}
		}
		close(IN)
	}
}

my $eix_functions = undef;
sub eixreadvar {
	my($name) = @_;
	return `\. \'$eix_functions\' \&\& ReadVar x $name \&\& printf \'\%s\' \"\$x\"`
}

sub getflags { my($useflags) = @_;
	# "Parse" the values of USE, PORTDIR, PORTDIR_OVERLAY from make.conf
	# and store it in into $iuse, $portdir, $overlays
	my($iuse, $portdir, $overlays);
	if(!defined($eix_functions)) {
		$eix_functions = `command -v eix-functions.sh 2\>/dev/null`;
		chomp($eix_functions)
	}
	if($eix_functions ne '') {
		$portdir = &eixreadvar('PORTDIR');
		$overlays = &eixreadvar('PORTDIR_OVERLAY');
	} else {
		$portdir = `portageq portdir`;
		chomp($portdir);
		$overlays = `portageq portdir_overlay`;
		chomp($overlays);
	}
	if(-r '/etc/make.conf') {
		$iuse = `bash -c \'\. /etc/make.conf ; printf \%s \"\$USE\"\'`
	} else {
		$iuse = ''
	}
	if(-r '/etc/portage/make.conf') {
		$iuse .= ' ' if($iuse ne '');
		$iuse .= `bash -c \'\. /etc/portage/make.conf ; printf \%s \"\$USE\"\'`
	}

	# If PORTDIR is not specified, we use the default
	if($portdir eq '') {
		$portdir = '/usr/portage'
	}

	# Now we parse all the profiles
	# (in /etc/make.profile, PORTDIR, OVERLAY, and in /etc/portage/profile)
	# using the recursive function &readprofile.

	%{$useflags} = ();
	if(-d '/etc/make.profile') {
		&readprofile(1, '/etc/make.profile', $useflags)
	} elsif(-d '/etc/portage/make.profile') {
		&readprofile(1, '/etc/portage/make.profile', $useflags)
	} else {
		&fatal("cannot find directory /etc\{,/portage\}/make.profile")
	}
	$_ = "$portdir $overlays";
	foreach(split) {
		chomp; &readprofile('', "$_/profiles", $useflags)
	}
	&readprofile('', '/etc/portage/profile', $useflags);

	# Now we interpret the value of the USE variable in /etc/make.conf:

	$_ = $iuse;
	(/^\s*$/) and
		&fatal("No USE variable specified in /etc/make.conf or /etc/portage/make.conf");
	foreach (split) {
		chomp;
		s/^\s*([^\s]*).*$/$1/;
		if(/^\-(.*)/) {
			useset($useflags, $1, -1)
		} else {
			useset($useflags, $_, 1)
		}
	}
}

sub printflags { my($useflags) = @_;
	foreach (sort (keys %$useflags)) {
		my $entry = &entry($useflags, $_);
		print "$_: ",&entry2text($entry),"\n" or &fatal("write error")
	}
}

sub saveflags { my($useflags, $name) = @_;
	open(OUT, '>', $name) or &fatal("cannot write to $name");
	select(OUT);
	&printflags($useflags);
	close(OUT);
	select(STDOUT);
}

sub loadflags { my($useflags, $name) = @_;
	%{$useflags} = ();
	open(IN, '<', $name) or &fatal("cannot read $name");
	while(<IN>) {
		chomp;
		s/^\s*//;
		s/\s*$//;
		s/^#.*//;
		if($_ ne '') {
			/^([^\s:]*)\s*[^:]*\s*(.*)/;
			if($1 ne '') {
				my $string = $2; # make sure to avoid side effects
				my $entry = &entry($useflags, $1);
				text2entry($entry, $string);
			}
		}
	}
}

sub compareflags { my($oldflags, $newflags);
	if($reverse) {
		($newflags, $oldflags) = @_
	} else {
		($oldflags, $newflags) = @_
	}
	my @array = (keys %$oldflags);
	push @array, (keys %$newflags);
	my $previous = '#';
	foreach (sort @array) {
		if($_ ne $previous) {
			$previous = $_; # make sure to avoid side effects
			my $old = 'NONE';
			my $new = $old;
			if(exists(${$oldflags}{$previous})) {
				$old = &entry2text(&entry($oldflags, $previous))
			}
			if(exists(${$newflags}{$previous})) {
				$new = &entry2text(&entry($newflags, $previous))
			}
			if($old ne $new) {
				print "$previous: $old -> $new\n"
			}
		}
	}
}

my %useflags = (); keys %useflags = 2000;
my %altflags = (); keys %altflags = 2000;

if($action =~ /save$/i || $action =~ /store/i) {
	my $name = $savepath;
	if($#ARGV == 1) {
		$name = $ARGV[1]
	} elsif($#ARGV != 0) {
		pod2usage('too many arguments for "save"')
	}
	&getflags(\%useflags);
	&saveflags(\%useflags, $name)
} elsif($action =~ /echo/i || $action =~ /print/i) {
	&getflags(\%useflags);
	&printflags(\%useflags)
} elsif($action =~ /cat/i || $action =~ /old/i || $action =~ /saved/i) {
	my $name = $savepath;
	if($#ARGV == 1) {
		$name = $ARGV[1]
	} elsif($#ARGV !=0 ) {
		pod2usage('too many arguments for "cat"')
	}
	&loadflags(\%useflags, $name);
	&printflags(\%useflags)
} elsif($action =~ /diff\D*(\d+)/i || $action =~ /comp\D*(\d+)/i) {
	&loadflags(\%useflags, "/gentoo32$savepath");
	&loadflags(\%altflags, "/gentoo64$savepath");
	&compareflags(\%useflags, \%altflags)
} elsif($action =~ /diff/i || $action =~ /comp/i) {
	if($#ARGV == 2) {
		&loadflags(\%useflags, $ARGV[1]);
		&loadflags(\%altflags, $ARGV[2]);
	} elsif($#ARGV == 1) {
		&loadflags(\%useflags, $ARGV[1]);
		&loadflags(\%altflags, $savepath);
	} elsif($#ARGV == 0) {
		&loadflags(\%useflags, $savepath);
		&getflags(\%altflags);
	} else {
		pod2usage('too many arguments for "diff"')
	}
	&compareflags(\%useflags, \%altflags)
} elsif($action =~ /help/i) {
	pod2usage(0)
} elsif($action =~ /man/i) {
	pod2usage(-verbose => 2)
} else {
	pod2usage("Unknown action: $action")
}
